##JS中的模块规范
####CommonJS
   一种模块化规定，适用于服务器端，加载只是从磁盘加载。同步加载模块，不适用异步加载，node中的应用模块就采用了CommonJS规范，规范规定：每个文件就是一个模块，有自己的作用域
   require()用来引入外部模块；
   exports对象用于导出当前模块的方法或变量，唯一的导出口
   module对象就代表模块本身
   
       特点：
       （1）所有代码都运行在模块作用域，不会污染全局作用域
       （2）模块可以多次加载，但只是在第一次加载时运行一次，然后运行结果就被缓存了，以后加载
       就直接从缓存读取，想让模块再次运行，必须清除缓存
       （3）模块的加载顺序，按照在代码出现的顺序加载
####AMD
  异步模块定义，适合在浏览器端，加载需要通过网络加载
  AMD规范使用define方法定义模块，AMD规范允许输出的模块兼容CommonJS规范
####CMD
   模块定义规范，明确了模块的基本书写格式和交互规则，也是使用define()定义模块
   
####模块加载器:倡导模块化开发的理念，核心价值是让js的模块化开发变得简单自然
   - RequireJS：等待所有依赖加载完毕，计算出模块定义函数正确的调用顺序，然后依次调用
     - 在html中引入requirejs
   
          <script src="/path/to/require.js" data-main="/path/to/app/config.js"></script>
         
       上面这种方式属于全局配置，属性 data-main 是告诉requirejs：你下载完以后，马上去载入真正的入口文件。
         它一般用来对requirejs进行配置，并且载入真正的程序模块。
     - 基本API    
      require定义三个变量：define,require,requiejs 其中require === requirejs
      define是用来定义一个模块，require是用来加载一个模块，并执行加载完后的回调函数
      require.config,用来配置模块加载的位置，paths配置可以使模块名字更加精炼，paths可以为文件配置多个
      路径
      
     - 第三方模块
      如果加载的模块不符合AMD规范，则使用shim,将该模块变为可用的模块
      
    - 循环依赖
      a文件依赖b,b也同时依赖a，这种情况就出现了循环依赖
      
####ES6 module